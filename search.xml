<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题复习-java线程(一)</title>
      <link href="/2023/08/17/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E6%80%BB%E5%A4%8D%E4%B9%A0(%E4%B8%80)/"/>
      <url>/2023/08/17/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E6%80%BB%E5%A4%8D%E4%B9%A0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、java-线程的创建方式"><a href="#一、java-线程的创建方式" class="headerlink" title="一、java 线程的创建方式"></a>一、java 线程的创建方式</h2><ul><li><p>1.继承Thread类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Demo</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(<span class="number">11</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.实现runnable接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(<span class="number">11</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3.使用lambda表达式（比较推荐这种方式）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        System.out.println(<span class="number">11</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(<span class="number">11</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4.实现callable接口（可以拿到任务的结果）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 创建FutureTask任务 优点可以拿到执行的结果</span></span><br><span class="line">             FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">             <span class="comment">// 将FutureTask传给线程</span></span><br><span class="line">             <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">             thread.start();</span><br><span class="line">             System.out.println(futureTask.get());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>5.使用线程池创建线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(<span class="number">11</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>为什么不建议使用Executors来创建线程池<br>  Executors的newFixedThreadPool构造方法如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  发现创建的队列为LinkedBlockingQueue，是一个无界阻塞队列，如果使用该线程池执行任务如果任务过多就会不断的添加到队列中，任务越多占用的内存就越多，最终可能耗尽内存，导致OOM。—OOM内存被使用完<br>  对于 Executors的newSingleThreadExecutor构造方法如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  同样也是LinkedBlockingQueue队列,会造成OOM内存消耗殆尽的事故</p></li><li><p>总结<br>除开有可能造成OOM之外，我们使用Executors来创建线程池也不能自定义现成的名字，不利于排查问题，所以建议直接使用ThreadPoolExecutor来定义线程池，可以灵活的来控制线程。</p></li></ul></li></ul><h2 id="二、线程池有那些状态"><a href="#二、线程池有那些状态" class="headerlink" title="二、线程池有那些状态"></a>二、线程池有那些状态</h2><ul><li><p>RUNNING</p><p>  Accept new tasks and process queued tasks<br>  表示线程池正常运行，既能够接受新的任务，也会正常处理队列中的任务。</p></li><li><p>SHUTDOWN</p><p>  Don’t accept new tasks,but process queued tasks<br>  当调用线程池的shutdown()方法时，线程池就会进入SHUTDOWN状态，表示线程池处于正在关闭状态，此状态下线程池不会接受新的任务，但是会继续把队列中的任务处理完毕。</p></li><li><p>STOP</p><p>  Don’t accept new tasks, don’t process queued tasks, and interrupt in-progress tasks<br>  当调用线程池的shutdownnow()方法时，线程池就进入STOP状态，表示线程池处于正在停止状态，此状态下线程池既不会接受新任务了，也不会处理队列中的任务，并且正在运行的线程也会被中断</p></li><li><p>TIDYING</p><p>  All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYINGwill run the terminated0 hook method<br>  线程池中没有线程在运行后，线程池的状态就会自动变为TIDYING，并且会调用terminated0,该方法是空方法，留给程序员进行扩展。</p></li><li><p>TERMINATED</p><p>  terminated() has completed<br>  terminated()方法执行完之后，线程池状态就会变为TERMINATED</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-双指针(快慢指针)</title>
      <link href="/2023/08/03/%E7%AE%97%E6%B3%95/pointer-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
      <url>/2023/08/03/%E7%AE%97%E6%B3%95/pointer-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="一、算法描述"><a href="#一、算法描述" class="headerlink" title="一、算法描述"></a>一、算法描述</h2><p>双指针，常用于处理数组类型的数据，通过俩个指针来指向不位置所代表的值也可以是相同位置的数值。</p><h2 id="二、算法实质"><a href="#二、算法实质" class="headerlink" title="二、算法实质"></a>二、算法实质</h2><p>双指针，通过操作俩个指针的指向来完成对于数据的处理。</p><h2 id="三、算法思想"><a href="#三、算法思想" class="headerlink" title="三、算法思想"></a>三、算法思想</h2><p>双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<strong>快慢指针</strong>）或者相反方向（<strong>对撞指针</strong>）的指针进行扫描，从而达到相应的目的。</p><p>过程图解：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20230803122447583.png" alt="image-20230803122447583"></p><h2 id="四、快慢指针使用条件"><a href="#四、快慢指针使用条件" class="headerlink" title="四、快慢指针使用条件"></a>四、快慢指针使用条件</h2><ul><li>在一个序列里边，用两个指针维护一段区间</li><li>在两个序列里边，一个指针指向其中一个序列，另外一个指针指向另外一个序列，来维护某种次序</li></ul><h2 id="五、案例"><a href="#五、案例" class="headerlink" title="五、案例"></a>五、案例</h2><ul><li><h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h3><ul><li><h4 id="题目-链接-https-leetcode-cn-problems-remove-duplicates-from-sorted-array-description"><a href="#题目-链接-https-leetcode-cn-problems-remove-duplicates-from-sorted-array-description" class="headerlink" title="题目 链接:https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/"></a>题目 链接:<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/</a></h4><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p></li><li><h4 id="判题标准"><a href="#判题标准" class="headerlink" title="判题标准"></a>判题标准</h4><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = [...]; <span class="comment">// 输入数组</span></span><br><span class="line"><span class="type">int</span>[] expectedNums = [...]; <span class="comment">// 长度正确的期望答案</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> removeDuplicates(nums); <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> k == expectedNums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="keyword">assert</span> nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p></li><li><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><ul><li>第一种情况 给定数组num长度为0 || 1不包含任何元素 直接返回0 || 1</li><li>第二种情况 在删除重复元素后至少剩下一个元素  保留nums[0] 删除后续元素</li><li>第三种情况，当nums大于0且删除重复元素后仍有其他元素，则定义两个指针一个快指针 fast 一个慢指针 slow，快指针标识遍历数组到达的下标位置，慢指针标识下一个不同元素要填入的下标位置，初始时两个指针都指向下标1，假设数组nums的长度为n，将快指针fast一次遍历从1到n-1的位置，对于每个位置如果nums[fast] != nums[fast-1] 说明nums[fast]和之前的元素都不同，因此将nums[fast]的值复制到nums[slow]，然后将slow的值+1即为指向下一个位置。遍历结束之后从nums[0]到nums[slow-1]的每个元素都不相同且包含原数组中的每个不同元素，因此新的长度即为slow返回slow即可。</li></ul></li><li><h4 id="官方代码"><a href="#官方代码" class="headerlink" title="官方代码"></a>官方代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度</p><ul><li>时间复杂度:O(n)，其中n为数组的长度。快慢指针最多各移动n次</li><li>空间复杂度:O(1)，只需要使用常数额外空间</li></ul></li></ul></li></ul><h2 id="六、个人见解"><a href="#六、个人见解" class="headerlink" title="六、个人见解"></a>六、个人见解</h2><ul><li><h3 id="个人解题代码"><a href="#个人解题代码" class="headerlink" title="个人解题代码"></a>个人解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] != nums[j]) &#123;</span><br><span class="line">                    nums[result] = nums[j];</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != nums.length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> result; i &lt; nums.length; i++) &#123;</span><br><span class="line">                nums[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="个人解题见解"><a href="#个人解题见解" class="headerlink" title="个人解题见解"></a>个人解题见解</h3><p>个人采用的是暴力解法，每次遍历到与该数值不相同的就进行交换，交换的位置为result的长度，每次交换后将i的数值等于j-1的位置继续开始，枚举出所有的情况，将所有不重复升序的数值提前，最后处理特别情况，如果result的长度不等于nums的长度就将后续值全部替换为-1等于是排除数组中全是1出现n+1次的情况。</p></li><li><h3 id="对于快慢指针的见解"><a href="#对于快慢指针的见解" class="headerlink" title="对于快慢指针的见解"></a>对于快慢指针的见解</h3><p>采用双指针的方式，可以很直观的解决数组中此类的问题，慢指针为条件下的位置，快指针通常为遍历数组寻找特定条件，当快指针越界时候为结束的条件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-递归</title>
      <link href="/2023/08/02/%E7%AE%97%E6%B3%95/recursion-%E9%80%92%E5%BD%92/"/>
      <url>/2023/08/02/%E7%AE%97%E6%B3%95/recursion-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="一、算法描述"><a href="#一、算法描述" class="headerlink" title="一、算法描述"></a>一、算法描述</h2><p>递归算法是一种直接或者间接调用自身函数或者方法的算法。说简单了就是程序自身的调用。</p><h2 id="二、算法实质"><a href="#二、算法实质" class="headerlink" title="二、算法实质"></a>二、算法实质</h2><p>递归算法就是将原问题不断分解为规模缩小的子问题，然后递归调用方法来表示 问题的解。（用同一个方法去解决规模不同的问题）</p><h2 id="三、算法思想"><a href="#三、算法思想" class="headerlink" title="三、算法思想"></a>三、算法思想</h2><p>递归算法，顾名思义就是有两个大的阶段：递和归，即就是有去（递去）有回（归来）。</p><ul><li>递去：将递归问题分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决</li><li>归来：当你将问题不断缩小规模递去的时候，必须有一个明确的结束递去的临界点（递归出口），一旦达到这个临界点即就从该点原路返回到原点，最终问题得到解决。</li></ul><p>过程图解：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/20200607172648138.jpg" alt="递归图解"></p><h2 id="四、递归算法使用条件"><a href="#四、递归算法使用条件" class="headerlink" title="四、递归算法使用条件"></a>四、递归算法使用条件</h2><ul><li>明确递归的终止条件</li><li>提取重复的逻辑，缩小问题的规模不断递去</li><li>给出递归终止时的处理办法</li></ul><h2 id="五、案例"><a href="#五、案例" class="headerlink" title="五、案例"></a>五、案例</h2><ul><li><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number * recursion(number - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="力扣（合并两个有序链表）"><a href="#力扣（合并两个有序链表）" class="headerlink" title="力扣（合并两个有序链表）"></a>力扣（合并两个有序链表）</h3><h4 id="题目-链接-https-leetcode-cn-problems-merge-two-sorted-lists-description"><a href="#题目-链接-https-leetcode-cn-problems-merge-two-sorted-lists-description" class="headerlink" title="题目 链接: https://leetcode.cn/problems/merge-two-sorted-lists/description/"></a>题目 链接: <a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">https://leetcode.cn/problems/merge-two-sorted-lists/description/</a></h4><p>  将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>  <img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/merge_ex1.jpg" alt="题目"></p><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>  采用递归算法，若l1 || l2 开始即为空链表，不需要操作返回非空链表，否则判断那个链表的头节点对应的值更小，然后递归，决定下一个添加到结果里的节点，如果后续递归中两个链表有一个为空递归结束。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       <span class="comment">// 排除非空集合</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">           <span class="comment">// 寻找最小头节点 每次递归节点 寻找插入的位置 每次更新链表 直到有一个值为空 就跳出递归</span></span><br><span class="line">           l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           l2.next = mergeTwoLists(l2.next, l1);</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，O(n+m)。</li><li>空间复杂度：O(n+m)，其中 n和 m分别为两个链表的长度。递归调mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。</li></ul></li></ul><h2 id="六、个人对于递归的理解-己见"><a href="#六、个人对于递归的理解-己见" class="headerlink" title="六、个人对于递归的理解(己见)"></a>六、个人对于递归的理解(己见)</h2><p>每次递归都会缩小范围，例如阶乘递归每次程序调用本身时参数就减一，从大规模逐渐减少到最后小规模的结束条件，输入5，每次递归减一 最终返回就是5 <em> 4 </em> 3 <em> 2 </em> 1 = 120（最后结束时候返回的结果），缩小到最小范围时候开始计算返回结果，也就是递归终止条件。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
