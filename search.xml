<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法-递归</title>
      <link href="/2023/08/02/%E7%AE%97%E6%B3%95/recursion-%E9%80%92%E5%BD%92/"/>
      <url>/2023/08/02/%E7%AE%97%E6%B3%95/recursion-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="一、算法描述"><a href="#一、算法描述" class="headerlink" title="一、算法描述"></a>一、算法描述</h2><p>递归算法是一种直接或者间接调用自身函数或者方法的算法。说简单了就是程序自身的调用。</p><h2 id="二、算法实质"><a href="#二、算法实质" class="headerlink" title="二、算法实质"></a>二、算法实质</h2><p>递归算法就是将原问题不断分解为规模缩小的子问题，然后递归调用方法来表示 问题的解。（用同一个方法去解决规模不同的问题）</p><h2 id="三、算法思想"><a href="#三、算法思想" class="headerlink" title="三、算法思想"></a>三、算法思想</h2><p>递归算法，顾名思义就是有两个大的阶段：递和归，即就是有去（递去）有回（归来）。</p><ul><li>递去：将递归问题分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决</li><li>归来：当你将问题不断缩小规模递去的时候，必须有一个明确的结束递去的临界点（递归出口），一旦达到这个临界点即就从该点原路返回到原点，最终问题得到解决。</li></ul><p>过程图解：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/20200607172648138.jpg" alt="递归图解"></p><h2 id="四、递归算法使用条件"><a href="#四、递归算法使用条件" class="headerlink" title="四、递归算法使用条件"></a>四、递归算法使用条件</h2><ul><li>明确递归的终止条件</li><li>提取重复的逻辑，缩小问题的规模不断递去</li><li>给出递归终止时的处理办法</li></ul><h2 id="五、案例"><a href="#五、案例" class="headerlink" title="五、案例"></a>五、案例</h2><ul><li><p>阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (number == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> number * recursion(number - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>力扣（合并两个有序链表）</p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>链接: <a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">https://leetcode.cn/problems/merge-two-sorted-lists/description/</a></p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/merge_ex1.jpg" alt="题目"></p><h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><p>采用递归算法，若l1 || l2 开始即为空链表，不需要操作返回非空链表，否则判断那个链表的头节点对应的值更小，然后递归，决定下一个添加到结果里的节点，如果后续递归中两个链表有一个为空递归结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       <span class="comment">// 排除非空集合</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">           <span class="comment">// 寻找最小头节点 每次递归节点 寻找插入的位置 每次更新链表 直到有一个值为空 就跳出递归</span></span><br><span class="line">           l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           l2.next = mergeTwoLists(l2.next, l1);</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，O(n+m)。</li><li>空间复杂度：O(n+m)，其中 n和 m分别为两个链表的长度。递归调mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。</li></ul></li></ul></li></ul><h4 id="六、个人对于递归的理解-己见"><a href="#六、个人对于递归的理解-己见" class="headerlink" title="六、个人对于递归的理解(己见)"></a>六、个人对于递归的理解(己见)</h4><p>每次递归都会缩小范围，例如阶乘递归每次程序调用本身时参数就减一，从大规模逐渐减少到最后小规模的结束条件，输入5，每次递归减一 最终返回就是5 <em> 4 </em> 3 <em> 2 </em> 1 = 120（最后结束时候返回的结果），缩小到最小范围时候开始计算返回结果，也就是递归终止条件。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
